using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using System.Collections.Immutable;
using System.Linq;

namespace AdvancedConcepts.Analyzers.Security;

[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class XssVulnerabilityAnalyzer : DiagnosticAnalyzer
{
    public const string DiagnosticId = "AC010";

    private static readonly LocalizableString Title = "Potential XSS vulnerability";
    private static readonly LocalizableString MessageFormat = "{0}";
    private static readonly LocalizableString Description = "Detects potential Cross-Site Scripting (XSS) vulnerabilities.";
    private const string Category = "Security";

    private static readonly DiagnosticDescriptor Rule = new DiagnosticDescriptor(
        DiagnosticId,
        Title,
        MessageFormat,
        Category,
        DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: Description);

    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);

    public override void Initialize(AnalysisContext context)
    {
        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
        context.EnableConcurrentExecution();

        context.RegisterSyntaxNodeAction(AnalyzeInvocation, SyntaxKind.InvocationExpression);
        context.RegisterSyntaxNodeAction(AnalyzeAssignment, SyntaxKind.SimpleAssignmentExpression);
    }

    private static void AnalyzeInvocation(SyntaxNodeAnalysisContext context)
    {
        var invocation = (InvocationExpressionSyntax)context.Node;

        // Check for Response.Write with unencoded user input
        if (invocation.Expression is MemberAccessExpressionSyntax memberAccess)
        {
            var methodName = memberAccess.Name.Identifier.Text;

            if (methodName == "Write" || methodName == "WriteAsync")
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(memberAccess);
                var method = symbolInfo.Symbol as IMethodSymbol;

                if (method?.ContainingType?.Name == "HttpResponse")
                {
                    // Check if argument is potentially user input
                    if (invocation.ArgumentList.Arguments.Any())
                    {
                        var argument = invocation.ArgumentList.Arguments[0].Expression;

                        if (IsUserInput(argument))
                        {
                            var diagnostic = Diagnostic.Create(
                                Rule,
                                invocation.GetLocation(),
                                "Potential XSS vulnerability: Writing user input to response without encoding. " +
                                "Use HttpUtility.HtmlEncode or Razor @Html.Raw with caution.");
                            context.ReportDiagnostic(diagnostic);
                        }
                    }
                }
            }

            // Check for Html.Raw() with user input
            if (methodName == "Raw")
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(memberAccess);
                var method = symbolInfo.Symbol as IMethodSymbol;

                if (method?.ContainingType?.Name == "HtmlHelper" ||
                    method?.ContainingType?.Name == "Html")
                {
                    if (invocation.ArgumentList.Arguments.Any())
                    {
                        var argument = invocation.ArgumentList.Arguments[0].Expression;

                        if (IsUserInput(argument))
                        {
                            var diagnostic = Diagnostic.Create(
                                Rule,
                                invocation.GetLocation(),
                                "Potential XSS vulnerability: Html.Raw() used with user input. " +
                                "User input should be HTML encoded.");
                            context.ReportDiagnostic(diagnostic);
                        }
                    }
                }
            }
        }
    }

    private static void AnalyzeAssignment(SyntaxNodeAnalysisContext context)
    {
        var assignment = (AssignmentExpressionSyntax)context.Node;

        // Check for innerHTML assignments in JavaScript generation
        var leftText = assignment.Left.ToString();

        if (leftText.Contains("innerHTML") || leftText.Contains("InnerHtml"))
        {
            if (IsUserInput(assignment.Right))
            {
                var diagnostic = Diagnostic.Create(
                    Rule,
                    assignment.GetLocation(),
                    "Potential XSS vulnerability: innerHTML assigned with user input. " +
                    "Encode user input or use textContent instead.");
                context.ReportDiagnostic(diagnostic);
            }
        }
    }

    private static bool IsUserInput(ExpressionSyntax expression)
    {
        var expressionText = expression.ToString();

        // Common patterns for user input
        var userInputIndicators = new[]
        {
            "Request.",
            ".Query",
            ".Form",
            ".RouteData",
            ".Headers",
            "HttpContext.",
            "UserInput",
            "Input",
            ".Value"
        };

        return userInputIndicators.Any(indicator => expressionText.Contains(indicator));
    }
}
