using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AdvancedConcepts.SourceGenerators;

/// <summary>
/// Source generator that creates compile-time validation methods for classes decorated with [Validate].
/// </summary>
[Generator]
public class ValidationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with Validate attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeContainingType = attributeSymbol.ContainingType;
                var fullName = attributeContainingType.ToDisplayString();

                if (fullName == "AdvancedConcepts.SourceGenerators.ValidateAttribute")
                    return classDeclaration;
            }
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        foreach (var classDeclaration in classes.Distinct())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                continue;

            var source = GenerateValidationCode(classSymbol);
            if (!string.IsNullOrEmpty(source))
            {
                context.AddSource($"{classSymbol.Name}_Validation.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string GenerateValidationCode(INamedTypeSymbol classSymbol)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Text.RegularExpressions;");
        sb.AppendLine();

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine($"public partial class {classSymbol.Name}");
        sb.AppendLine("{");

        // Generate ValidationResult class
        GenerateValidationResultClass(sb);

        // Generate Validate method
        GenerateValidateMethod(sb, classSymbol);

        // Generate IsValid method
        GenerateIsValidMethod(sb);

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateValidationResultClass(StringBuilder sb)
    {
        sb.AppendLine("    public class ValidationResult");
        sb.AppendLine("    {");
        sb.AppendLine("        public bool IsValid { get; set; }");
        sb.AppendLine("        public List<string> Errors { get; set; } = new();");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateValidateMethod(StringBuilder sb, INamedTypeSymbol classSymbol)
    {
        sb.AppendLine("    public ValidationResult Validate()");
        sb.AppendLine("    {");
        sb.AppendLine("        var result = new ValidationResult { IsValid = true };");
        sb.AppendLine();

        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToList();

        foreach (var property in properties)
        {
            var attributes = property.GetAttributes();

            // Required validation
            var requiredAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "RequiredAttribute");
            if (requiredAttr is not null)
            {
                GenerateRequiredValidation(sb, property, requiredAttr);
            }

            // StringLength validation
            var stringLengthAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "StringLengthAttribute");
            if (stringLengthAttr is not null)
            {
                GenerateStringLengthValidation(sb, property, stringLengthAttr);
            }

            // EmailAddress validation
            var emailAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "EmailAddressAttribute");
            if (emailAttr is not null)
            {
                GenerateEmailValidation(sb, property, emailAttr);
            }

            // Range validation
            var rangeAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "RangeAttribute");
            if (rangeAttr is not null)
            {
                GenerateRangeValidation(sb, property, rangeAttr);
            }

            // RegularExpression validation
            var regexAttr = attributes.FirstOrDefault(a => a.AttributeClass?.Name == "RegularExpressionAttribute");
            if (regexAttr is not null)
            {
                GenerateRegexValidation(sb, property, regexAttr);
            }
        }

        sb.AppendLine();
        sb.AppendLine("        return result;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateRequiredValidation(StringBuilder sb, IPropertySymbol property, AttributeData attr)
    {
        var errorMessage = GetErrorMessage(attr, $"{property.Name} is required");

        if (property.Type.SpecialType == SpecialType.System_String)
        {
            sb.AppendLine($"        if (string.IsNullOrWhiteSpace({property.Name}))");
            sb.AppendLine("        {");
            sb.AppendLine($"            result.IsValid = false;");
            sb.AppendLine($"            result.Errors.Add(\"{errorMessage}\");");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
    }

    private static void GenerateStringLengthValidation(StringBuilder sb, IPropertySymbol property, AttributeData attr)
    {
        var maxLength = attr.ConstructorArguments[0].Value;
        var minLength = GetNamedArgument(attr, "MinimumLength", 0);
        var errorMessage = GetErrorMessage(attr, $"{property.Name} must be between {minLength} and {maxLength} characters");

        sb.AppendLine($"        if ({property.Name} != null)");
        sb.AppendLine("        {");
        sb.AppendLine($"            if ({property.Name}.Length < {minLength} || {property.Name}.Length > {maxLength})");
        sb.AppendLine("            {");
        sb.AppendLine($"                result.IsValid = false;");
        sb.AppendLine($"                result.Errors.Add(\"{errorMessage}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateEmailValidation(StringBuilder sb, IPropertySymbol property, AttributeData attr)
    {
        var errorMessage = GetErrorMessage(attr, $"{property.Name} must be a valid email address");

        sb.AppendLine($"        if (!string.IsNullOrEmpty({property.Name}))");
        sb.AppendLine("        {");
        sb.AppendLine($"            var emailRegex = new Regex(@\"^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$\");");
        sb.AppendLine($"            if (!emailRegex.IsMatch({property.Name}))");
        sb.AppendLine("            {");
        sb.AppendLine($"                result.IsValid = false;");
        sb.AppendLine($"                result.Errors.Add(\"{errorMessage}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateRangeValidation(StringBuilder sb, IPropertySymbol property, AttributeData attr)
    {
        var minimum = attr.ConstructorArguments[0].Value;
        var maximum = attr.ConstructorArguments[1].Value;
        var errorMessage = GetErrorMessage(attr, $"{property.Name} must be between {minimum} and {maximum}");

        sb.AppendLine($"        if ({property.Name} < {minimum} || {property.Name} > {maximum})");
        sb.AppendLine("        {");
        sb.AppendLine($"            result.IsValid = false;");
        sb.AppendLine($"            result.Errors.Add(\"{errorMessage}\");");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateRegexValidation(StringBuilder sb, IPropertySymbol property, AttributeData attr)
    {
        var pattern = attr.ConstructorArguments[0].Value?.ToString() ?? "";
        var errorMessage = GetErrorMessage(attr, $"{property.Name} format is invalid");

        sb.AppendLine($"        if (!string.IsNullOrEmpty({property.Name}))");
        sb.AppendLine("        {");
        sb.AppendLine($"            var regex = new Regex(@\"{pattern}\");");
        sb.AppendLine($"            if (!regex.IsMatch({property.Name}))");
        sb.AppendLine("            {");
        sb.AppendLine($"                result.IsValid = false;");
        sb.AppendLine($"                result.Errors.Add(\"{errorMessage}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateIsValidMethod(StringBuilder sb)
    {
        sb.AppendLine("    public bool IsValid()");
        sb.AppendLine("    {");
        sb.AppendLine("        return Validate().IsValid;");
        sb.AppendLine("    }");
    }

    private static string GetErrorMessage(AttributeData attr, string defaultMessage)
    {
        var errorMessage = GetNamedArgument(attr, "ErrorMessage", "")?.ToString() ?? "";
        return string.IsNullOrEmpty(errorMessage) ? defaultMessage : errorMessage;
    }

    private static object? GetNamedArgument(AttributeData attr, string name, object? defaultValue)
    {
        var arg = attr.NamedArguments.FirstOrDefault(a => a.Key == name);
        return arg.Value.Value ?? defaultValue;
    }
}
