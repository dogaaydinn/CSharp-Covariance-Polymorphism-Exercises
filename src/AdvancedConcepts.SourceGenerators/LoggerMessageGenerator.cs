using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AdvancedConcepts.SourceGenerators;

/// <summary>
/// Source generator that creates high-performance logging methods for partial methods decorated with [LoggerMessage].
/// </summary>
[Generator]
public class LoggerMessageGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute source
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "LoggerMessageAttribute.g.cs",
            SourceText.From(AttributeSource, Encoding.UTF8)));

        // Find all partial methods with LoggerMessage attribute
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndMethods = context.CompilationProvider.Combine(methodDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndMethods,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is MethodDeclarationSyntax methodDeclaration &&
               methodDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword) &&
               methodDeclaration.AttributeLists.Count > 0;
    }

    private static MethodDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var methodDeclaration = (MethodDeclarationSyntax)context.Node;

        foreach (var attributeList in methodDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeContainingType = attributeSymbol.ContainingType;
                var fullName = attributeContainingType.ToDisplayString();

                if (fullName == "AdvancedConcepts.SourceGenerators.LoggerMessageAttribute")
                    return methodDeclaration;
            }
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<MethodDeclarationSyntax> methods,
        SourceProductionContext context)
    {
        if (methods.IsDefaultOrEmpty)
            return;

        var loggerMessageAttribute = compilation.GetTypeByMetadataName("AdvancedConcepts.SourceGenerators.LoggerMessageAttribute");
        if (loggerMessageAttribute is null)
            return;

        // Group methods by containing class
        var methodsByClass = methods
            .GroupBy(m =>
            {
                var semanticModel = compilation.GetSemanticModel(m.SyntaxTree);
                return semanticModel.GetDeclaredSymbol(m)?.ContainingType;
            })
            .Where(g => g.Key is not null);

        foreach (var group in methodsByClass)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var containingType = group.Key!;
            var methodSymbols = group
                .Select(m =>
                {
                    var semanticModel = compilation.GetSemanticModel(m.SyntaxTree);
                    return semanticModel.GetDeclaredSymbol(m) as IMethodSymbol;
                })
                .Where(m => m is not null)
                .Cast<IMethodSymbol>()
                .ToList();

            var source = GenerateLoggerMethods(containingType, methodSymbols, loggerMessageAttribute);
            if (!string.IsNullOrEmpty(source))
            {
                context.AddSource($"{containingType.Name}_LoggerMessage.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string GenerateLoggerMethods(
        INamedTypeSymbol containingType,
        List<IMethodSymbol> methods,
        INamedTypeSymbol loggerMessageAttribute)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine();

        var namespaceName = containingType.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        // Start class/struct declaration
        var typeKind = containingType.TypeKind == TypeKind.Struct ? "struct" : "class";
        var modifiers = containingType.DeclaredAccessibility == Accessibility.Public ? "public" : "internal";

        sb.AppendLine($"{modifiers} static partial {typeKind} {containingType.Name}");
        sb.AppendLine("{");

        foreach (var method in methods)
        {
            var attribute = method.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, loggerMessageAttribute));

            if (attribute is null)
                continue;

            GenerateLoggerMethod(sb, method, attribute);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateLoggerMethod(StringBuilder sb, IMethodSymbol method, AttributeData attribute)
    {
        // Extract attribute properties
        var eventId = 0;
        var level = "Information";
        var message = string.Empty;
        var eventName = method.Name;
        var skipEnabledCheck = false;

        foreach (var namedArg in attribute.NamedArguments)
        {
            switch (namedArg.Key)
            {
                case "EventId":
                    eventId = (int)namedArg.Value.Value!;
                    break;
                case "Level":
                    level = namedArg.Value.Value!.ToString()!;
                    break;
                case "Message":
                    message = (string)namedArg.Value.Value!;
                    break;
                case "EventName":
                    eventName = (string)namedArg.Value.Value!;
                    break;
                case "SkipEnabledCheck":
                    skipEnabledCheck = (bool)namedArg.Value.Value!;
                    break;
            }
        }

        // Get parameters (skip ILogger parameter)
        var parameters = method.Parameters
            .Where(p => !p.Type.Name.Contains("ILogger"))
            .ToList();

        var loggerParam = method.Parameters.FirstOrDefault(p => p.Type.Name.Contains("ILogger"));
        var loggerParamName = loggerParam?.Name ?? "logger";

        // Generate method
        sb.AppendLine();
        sb.AppendLine($"    private static readonly Action<ILogger, {string.Join(", ", parameters.Select(p => p.Type.ToDisplayString()))}, Exception?> _{method.Name}Delegate =");
        sb.AppendLine($"        LoggerMessage.Define<{string.Join(", ", parameters.Select(p => p.Type.ToDisplayString()))}>(");
        sb.AppendLine($"            LogLevel.{level},");
        sb.AppendLine($"            new EventId({eventId}, \"{eventName}\"),");
        sb.AppendLine($"            \"{message}\");");
        sb.AppendLine();

        // Generate method signature
        sb.Append($"    public static partial void {method.Name}(");

        var methodParams = new List<string>();
        if (loggerParam is not null)
            methodParams.Add($"ILogger {loggerParamName}");

        methodParams.AddRange(parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));

        sb.Append(string.Join(", ", methodParams));
        sb.AppendLine(")");
        sb.AppendLine("    {");

        if (!skipEnabledCheck)
        {
            sb.AppendLine($"        if (!{loggerParamName}.IsEnabled(LogLevel.{level}))");
            sb.AppendLine("            return;");
            sb.AppendLine();
        }

        sb.Append($"        _{method.Name}Delegate({loggerParamName}");
        if (parameters.Any())
        {
            sb.Append(", ");
            sb.Append(string.Join(", ", parameters.Select(p => p.Name)));
        }
        sb.AppendLine(", null);");
        sb.AppendLine("    }");
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

using System;

namespace AdvancedConcepts.SourceGenerators
{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
    internal sealed class LoggerMessageAttribute : Attribute
    {
        public int EventId { get; set; }
        public LogLevel Level { get; set; } = LogLevel.Information;
        public string Message { get; set; } = string.Empty;
        public string? EventName { get; set; }
        public bool SkipEnabledCheck { get; set; } = false;
    }

    internal enum LogLevel
    {
        Trace = 0,
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5,
        None = 6
    }
}
";
}
