using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace AdvancedConcepts.SourceGenerators;

/// <summary>
/// Source generator that creates automatic mapping extension methods for types decorated with [AutoMap].
/// </summary>
[Generator]
public class AutoMapGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute source
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "AutoMapAttribute.g.cs",
            SourceText.From(AttributeSource, Encoding.UTF8)));

        // Find all classes with AutoMap attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeContainingType = attributeSymbol.ContainingType;
                var fullName = attributeContainingType.ToDisplayString();

                if (fullName == "AdvancedConcepts.SourceGenerators.AutoMapAttribute")
                    return classDeclaration;
            }
        }

        return null;
    }

    private static void Execute(
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        var autoMapAttribute = compilation.GetTypeByMetadataName("AdvancedConcepts.SourceGenerators.AutoMapAttribute");
        if (autoMapAttribute is null)
            return;

        foreach (var classDeclaration in classes.Distinct())
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
                continue;

            var source = GenerateMappingExtensions(classSymbol, autoMapAttribute);
            if (!string.IsNullOrEmpty(source))
            {
                context.AddSource($"{classSymbol.Name}_AutoMap.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string GenerateMappingExtensions(INamedTypeSymbol sourceType, INamedTypeSymbol autoMapAttribute)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine();

        var namespaceName = sourceType.ContainingNamespace.ToDisplayString();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Auto-generated mapping extensions for {sourceType.Name}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {sourceType.Name}MappingExtensions");
        sb.AppendLine("{");

        // Get all AutoMap attributes
        var autoMapAttributes = sourceType.GetAttributes()
            .Where(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, autoMapAttribute))
            .ToList();

        foreach (var attribute in autoMapAttributes)
        {
            if (attribute.ConstructorArguments.IsEmpty)
                continue;

            var targetTypeArg = attribute.ConstructorArguments[0];
            if (targetTypeArg.Value is not INamedTypeSymbol targetType)
                continue;

            // Get attribute properties
            var generateReverseMap = true;
            var ignoreMissingProperties = false;

            foreach (var namedArg in attribute.NamedArguments)
            {
                if (namedArg.Key == "GenerateReverseMap")
                    generateReverseMap = (bool)namedArg.Value.Value!;
                else if (namedArg.Key == "IgnoreMissingProperties")
                    ignoreMissingProperties = (bool)namedArg.Value.Value!;
            }

            // Generate mapping method
            GenerateMappingMethod(sb, sourceType, targetType, ignoreMissingProperties);

            // Generate reverse mapping if requested
            if (generateReverseMap)
            {
                GenerateMappingMethod(sb, targetType, sourceType, ignoreMissingProperties);
            }
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateMappingMethod(
        StringBuilder sb,
        INamedTypeSymbol sourceType,
        INamedTypeSymbol targetType,
        bool ignoreMissingProperties)
    {
        var methodName = $"To{targetType.Name}";
        var sourceProperties = GetMappableProperties(sourceType);
        var targetProperties = GetMappableProperties(targetType).ToDictionary(p => p.Name);

        sb.AppendLine();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// Maps {sourceType.Name} to {targetType.Name}.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static {targetType.ToDisplayString()} {methodName}(this {sourceType.ToDisplayString()} source)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (source == null)");
        sb.AppendLine("            throw new ArgumentNullException(nameof(source));");
        sb.AppendLine();
        sb.AppendLine($"        return new {targetType.ToDisplayString()}");
        sb.AppendLine("        {");

        var mappings = sourceProperties
            .Where(sourceProp =>
            {
                // Check for AutoMapIgnore attribute
                if (sourceProp.GetAttributes().Any(a =>
                    a.AttributeClass?.Name == "AutoMapIgnoreAttribute"))
                    return false;

                // Check if property exists in target
                var targetPropertyName = GetTargetPropertyName(sourceProp);
                return ignoreMissingProperties || targetProperties.ContainsKey(targetPropertyName);
            })
            .ToList();

        for (int i = 0; i < mappings.Count; i++)
        {
            var sourceProp = mappings[i];
            var targetPropertyName = GetTargetPropertyName(sourceProp);

            if (targetProperties.TryGetValue(targetPropertyName, out var targetProp))
            {
                sb.Append($"            {targetPropertyName} = source.{sourceProp.Name}");

                // Add comma if not last property
                if (i < mappings.Count - 1)
                    sb.AppendLine(",");
                else
                    sb.AppendLine();
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static string GetTargetPropertyName(IPropertySymbol property)
    {
        var mapPropertyAttr = property.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "AutoMapPropertyAttribute");

        if (mapPropertyAttr is not null &&
            mapPropertyAttr.ConstructorArguments.Length > 0 &&
            mapPropertyAttr.ConstructorArguments[0].Value is string targetName)
        {
            return targetName;
        }

        return property.Name;
    }

    private static ImmutableArray<IPropertySymbol> GetMappableProperties(INamedTypeSymbol type)
    {
        return type.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                        !p.IsStatic &&
                        p.GetMethod is not null &&
                        p.SetMethod is not null)
            .ToImmutableArray();
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

using System;

namespace AdvancedConcepts.SourceGenerators
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    internal sealed class AutoMapAttribute : Attribute
    {
        public Type TargetType { get; }
        public string? MethodNamePrefix { get; set; }
        public bool GenerateReverseMap { get; set; } = true;
        public bool IgnoreMissingProperties { get; set; } = false;

        public AutoMapAttribute(Type targetType)
        {
            TargetType = targetType ?? throw new ArgumentNullException(nameof(targetType));
        }
    }

    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
    internal sealed class AutoMapIgnoreAttribute : Attribute
    {
    }

    [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
    internal sealed class AutoMapPropertyAttribute : Attribute
    {
        public string TargetPropertyName { get; }

        public AutoMapPropertyAttribute(string targetPropertyName)
        {
            TargetPropertyName = targetPropertyName ?? throw new ArgumentNullException(nameof(targetPropertyName));
        }
    }
}
";
}
