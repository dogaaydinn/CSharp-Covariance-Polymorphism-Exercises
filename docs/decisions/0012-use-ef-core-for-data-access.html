<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>12. Use Entity Framework Core for Data Access | Advanced C# Concepts </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="12. Use Entity Framework Core for Data Access | Advanced C# Concepts ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="">
      <meta name="docfx:tocrel" content="">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dogaaydinn/CSharp-Covariance-Polymorphism-Exercises/blob/master/docs/decisions/0012-use-ef-core-for-data-access.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="12-use-entity-framework-core-for-data-access">12. Use Entity Framework Core for Data Access</h1>

<p><strong>Status:</strong> ✅ Accepted</p>
<p><strong>Date:</strong> 2024-12-01</p>
<p><strong>Deciders:</strong> Architecture Team, Database Team</p>
<p><strong>Technical Story:</strong> Implementation in <code>samples/05-RealWorld/MicroserviceTemplate/Infrastructure</code></p>
<hr>
<h2 id="context-and-problem-statement">Context and Problem Statement</h2>
<p>Applications need to interact with databases to:</p>
<ul>
<li>Read and write business entities</li>
<li>Execute complex queries</li>
<li>Manage database schema migrations</li>
<li>Handle transactions</li>
</ul>
<p><strong>Traditional ADO.NET problems:</strong></p>
<ul>
<li>Verbose code (100+ lines for simple CRUD)</li>
<li>Manual object mapping</li>
<li>SQL injection risks</li>
<li>No schema migration support</li>
<li>Tedious connection management</li>
</ul>
<p><strong>Requirements:</strong></p>
<ul>
<li>Object-Relational Mapping (ORM)</li>
<li>LINQ query support</li>
<li>Database migrations</li>
<li>Multiple database support (PostgreSQL, SQL Server, SQLite)</li>
<li>Change tracking</li>
<li>Transaction management</li>
</ul>
<hr>
<h2 id="decision-drivers">Decision Drivers</h2>
<ul>
<li><strong>Productivity</strong> - Reduce boilerplate code</li>
<li><strong>Type Safety</strong> - Compile-time query validation</li>
<li><strong>LINQ Support</strong> - Write queries in C#, not SQL</li>
<li><strong>Migrations</strong> - Automatic schema versioning</li>
<li><strong>Microsoft Support</strong> - First-party solution</li>
<li><strong>Performance</strong> - Efficient SQL generation</li>
</ul>
<hr>
<h2 id="considered-options">Considered Options</h2>
<ul>
<li><strong>Option 1</strong> - Entity Framework Core (EF Core)</li>
<li><strong>Option 2</strong> - Dapper (micro-ORM)</li>
<li><strong>Option 3</strong> - ADO.NET (raw SQL)</li>
<li><strong>Option 4</strong> - NHibernate</li>
</ul>
<hr>
<h2 id="decision-outcome">Decision Outcome</h2>
<p><strong>Chosen option:</strong> &quot;Entity Framework Core&quot;, because it provides full-featured ORM with LINQ support, automatic migrations, change tracking, and excellent developer productivity while maintaining good performance for most scenarios.</p>
<h3 id="positive-consequences">Positive Consequences</h3>
<ul>
<li><strong>Productivity</strong> - 10x less code than ADO.NET</li>
<li><strong>Type-Safe Queries</strong> - LINQ instead of string SQL</li>
<li><strong>Migrations</strong> - Automatic schema management</li>
<li><strong>Change Tracking</strong> - Automatic UPDATE statement generation</li>
<li><strong>Database Agnostic</strong> - Swap providers easily</li>
<li><strong>Eager/Lazy Loading</strong> - Control data loading strategy</li>
<li><strong>Microsoft Support</strong> - First-party, well-documented</li>
</ul>
<h3 id="negative-consequences">Negative Consequences</h3>
<ul>
<li><strong>Performance Overhead</strong> - 10-30% slower than Dapper for simple queries</li>
<li><strong>Complexity</strong> - N+1 query problem if not careful</li>
<li><strong>Learning Curve</strong> - Team needs to understand EF Core patterns</li>
<li><strong>Black Box</strong> - Generated SQL can be surprising</li>
</ul>
<hr>
<h2 id="pros-and-cons-of-the-options">Pros and Cons of the Options</h2>
<h3 id="entity-framework-core-chosen">Entity Framework Core (Chosen)</h3>
<p><strong>What is EF Core?</strong></p>
<p>Entity Framework Core is a modern object-relational mapper (ORM) that enables .NET developers to work with databases using .NET objects, eliminating most data-access code.</p>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>LINQ Queries</strong> - Write queries in C#</li>
<li><strong>Change Tracking</strong> - Automatically detect modifications</li>
<li><strong>Migrations</strong> - Schema versioning</li>
<li><strong>Database Providers</strong> - PostgreSQL, SQL Server, SQLite, MySQL, Cosmos DB, etc.</li>
<li><strong>Lazy/Eager Loading</strong> - Control when related data loads</li>
<li><strong>Global Query Filters</strong> - Soft delete, multi-tenancy</li>
<li><strong>Split Queries</strong> - Avoid cartesian explosion</li>
<li><strong>Compiled Queries</strong> - Cache query execution plans</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Performance</strong> - Overhead compared to micro-ORMs</li>
<li><strong>N+1 Problem</strong> - Easy to create inefficient queries</li>
<li><strong>Complex SQL</strong> - Some queries better as raw SQL</li>
<li><strong>Memory Usage</strong> - Change tracking uses RAM</li>
</ul>
<p><strong>Installation:</strong></p>
<pre><code class="lang-bash">dotnet add package Microsoft.EntityFrameworkCore
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
dotnet add package Microsoft.EntityFrameworkCore.Design
</code></pre>
<p><strong>DbContext Setup:</strong></p>
<pre><code class="lang-csharp">public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions&lt;ApplicationDbContext&gt; options)
        : base(options)
    {
    }

    public DbSet&lt;Product&gt; Products { get; set; }
    public DbSet&lt;Category&gt; Categories { get; set; }
    public DbSet&lt;Order&gt; Orders { get; set; }
    public DbSet&lt;OrderItem&gt; OrderItems { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Configure entities
        modelBuilder.Entity&lt;Product&gt;(entity =&gt;
        {
            entity.ToTable(&quot;products&quot;);

            entity.HasKey(p =&gt; p.Id);

            entity.Property(p =&gt; p.Name)
                .IsRequired()
                .HasMaxLength(200);

            entity.Property(p =&gt; p.Price)
                .HasColumnType(&quot;decimal(18,2)&quot;);

            entity.HasIndex(p =&gt; p.Name);

            // Relationship
            entity.HasOne(p =&gt; p.Category)
                .WithMany(c =&gt; c.Products)
                .HasForeignKey(p =&gt; p.CategoryId);

            // Global query filter (soft delete)
            entity.HasQueryFilter(p =&gt; !p.IsDeleted);
        });

        modelBuilder.Entity&lt;Order&gt;(entity =&gt;
        {
            entity.ToTable(&quot;orders&quot;);

            // Owned type (value object)
            entity.OwnsOne(o =&gt; o.ShippingAddress, address =&gt;
            {
                address.Property(a =&gt; a.Street).HasColumnName(&quot;shipping_street&quot;);
                address.Property(a =&gt; a.City).HasColumnName(&quot;shipping_city&quot;);
            });

            // One-to-many
            entity.HasMany(o =&gt; o.Items)
                .WithOne(i =&gt; i.Order)
                .HasForeignKey(i =&gt; i.OrderId)
                .OnDelete(DeleteBehavior.Cascade);
        });

        // Seed data
        modelBuilder.Entity&lt;Category&gt;().HasData(
            new Category { Id = 1, Name = &quot;Electronics&quot; },
            new Category { Id = 2, Name = &quot;Books&quot; }
        );
    }
}
</code></pre>
<p><strong>Program.cs Registration:</strong></p>
<pre><code class="lang-csharp">builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;
    options.UseNpgsql(
        builder.Configuration.GetConnectionString(&quot;DefaultConnection&quot;),
        npgsqlOptions =&gt;
        {
            npgsqlOptions.EnableRetryOnFailure(
                maxRetryCount: 3,
                maxRetryDelay: TimeSpan.FromSeconds(5),
                errorCodesToAdd: null);

            npgsqlOptions.MigrationsAssembly(&quot;Infrastructure&quot;);
            npgsqlOptions.CommandTimeout(30);
        })
    .LogTo(Console.WriteLine, LogLevel.Information)  // Log SQL (dev only)
    .EnableSensitiveDataLogging()  // Log parameter values (dev only)
    .EnableDetailedErrors());      // Detailed error messages (dev only)
</code></pre>
<p><strong>Repository Pattern:</strong></p>
<pre><code class="lang-csharp">public interface IProductRepository
{
    Task&lt;Product?&gt; GetByIdAsync(int id, CancellationToken ct = default);
    Task&lt;List&lt;Product&gt;&gt; GetAllAsync(CancellationToken ct = default);
    Task&lt;Product&gt; AddAsync(Product product, CancellationToken ct = default);
    Task UpdateAsync(Product product, CancellationToken ct = default);
    Task DeleteAsync(int id, CancellationToken ct = default);
}

public class ProductRepository : IProductRepository
{
    private readonly ApplicationDbContext _context;

    public ProductRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task&lt;Product?&gt; GetByIdAsync(int id, CancellationToken ct = default)
    {
        return await _context.Products
            .Include(p =&gt; p.Category)  // Eager load
            .AsNoTracking()            // Read-only query (faster)
            .FirstOrDefaultAsync(p =&gt; p.Id == id, ct);
    }

    public async Task&lt;List&lt;Product&gt;&gt; GetAllAsync(CancellationToken ct = default)
    {
        return await _context.Products
            .Include(p =&gt; p.Category)
            .AsNoTracking()
            .ToListAsync(ct);
    }

    public async Task&lt;Product&gt; AddAsync(Product product, CancellationToken ct = default)
    {
        _context.Products.Add(product);
        await _context.SaveChangesAsync(ct);
        return product;
    }

    public async Task UpdateAsync(Product product, CancellationToken ct = default)
    {
        _context.Products.Update(product);
        await _context.SaveChangesAsync(ct);
    }

    public async Task DeleteAsync(int id, CancellationToken ct = default)
    {
        var product = await _context.Products.FindAsync(new object[] { id }, ct);
        if (product != null)
        {
            _context.Products.Remove(product);
            await _context.SaveChangesAsync(ct);
        }
    }
}
</code></pre>
<p><strong>Advanced Queries:</strong></p>
<p><strong>1. Complex LINQ:</strong></p>
<pre><code class="lang-csharp">// Get products with price between $10-$100, in Electronics category, ordered by name
var products = await _context.Products
    .Where(p =&gt; p.Price &gt;= 10 &amp;&amp; p.Price &lt;= 100)
    .Where(p =&gt; p.Category.Name == &quot;Electronics&quot;)
    .OrderBy(p =&gt; p.Name)
    .Select(p =&gt; new ProductDto
    {
        Id = p.Id,
        Name = p.Name,
        Price = p.Price,
        CategoryName = p.Category.Name
    })
    .ToListAsync();

// Generated SQL:
// SELECT p.id, p.name, p.price, c.name
// FROM products p
// INNER JOIN categories c ON p.category_id = c.id
// WHERE p.price &gt;= 10 AND p.price &lt;= 100 AND c.name = 'Electronics'
// ORDER BY p.name
</code></pre>
<p><strong>2. Avoid N+1 Problem:</strong></p>
<pre><code class="lang-csharp">// ❌ BAD: N+1 queries
var orders = await _context.Orders.ToListAsync();
foreach (var order in orders)  // 1 query
{
    var items = await _context.OrderItems
        .Where(i =&gt; i.OrderId == order.Id)
        .ToListAsync();  // N queries (1 per order)
}

// ✅ GOOD: Single query with Include
var orders = await _context.Orders
    .Include(o =&gt; o.Items)
        .ThenInclude(i =&gt; i.Product)
    .ToListAsync();  // 1 query
</code></pre>
<p><strong>3. Split Query (Avoid Cartesian Explosion):</strong></p>
<pre><code class="lang-csharp">// ❌ BAD: Cartesian explosion when including multiple collections
var orders = await _context.Orders
    .Include(o =&gt; o.Items)      // 10 items per order
    .Include(o =&gt; o.Payments)   // 3 payments per order
    .ToListAsync();
// Returns: 1 order × 10 items × 3 payments = 30 rows (duplicates!)

// ✅ GOOD: Split into separate queries
var orders = await _context.Orders
    .Include(o =&gt; o.Items)
    .Include(o =&gt; o.Payments)
    .AsSplitQuery()  // Executes 3 queries instead of 1
    .ToListAsync();
// Query 1: SELECT * FROM orders
// Query 2: SELECT * FROM order_items WHERE order_id IN (...)
// Query 3: SELECT * FROM payments WHERE order_id IN (...)
</code></pre>
<p><strong>4. Raw SQL (When Needed):</strong></p>
<pre><code class="lang-csharp">// Execute raw SQL query
var products = await _context.Products
    .FromSqlRaw(&quot;SELECT * FROM products WHERE price &gt; {0}&quot;, 100)
    .ToListAsync();

// Execute stored procedure
var result = await _context.Database
    .ExecuteSqlRawAsync(&quot;EXEC GenerateMonthlyReport @Month={0}&quot;, month);
</code></pre>
<p><strong>5. Transactions:</strong></p>
<pre><code class="lang-csharp">using var transaction = await _context.Database.BeginTransactionAsync();
try
{
    var order = new Order { /* ... */ };
    _context.Orders.Add(order);
    await _context.SaveChangesAsync();

    foreach (var item in orderItems)
    {
        item.OrderId = order.Id;
        _context.OrderItems.Add(item);
    }
    await _context.SaveChangesAsync();

    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
</code></pre>
<p><strong>Migrations:</strong></p>
<pre><code class="lang-bash"># Create migration
dotnet ef migrations add InitialCreate --project Infrastructure --startup-project API

# Apply migration
dotnet ef database update --project Infrastructure --startup-project API

# Generate SQL script
dotnet ef migrations script --project Infrastructure --startup-project API --output migration.sql
</code></pre>
<h3 id="dapper-micro-orm">Dapper (Micro-ORM)</h3>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>Fast</strong> - Minimal overhead, 2-3x faster than EF Core</li>
<li><strong>Simple</strong> - Straightforward API</li>
<li><strong>Control</strong> - Write exact SQL you want</li>
<li><strong>No change tracking</strong> - Lower memory usage</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>No migrations</strong> - Manage schema manually</li>
<li><strong>Manual mapping</strong> - Write SQL and map to objects</li>
<li><strong>No LINQ</strong> - String-based queries</li>
<li><strong>More code</strong> - Repository boilerplate required</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="lang-csharp">// Dapper
public async Task&lt;Product?&gt; GetByIdAsync(int id)
{
    using var connection = new NpgsqlConnection(_connectionString);
    return await connection.QueryFirstOrDefaultAsync&lt;Product&gt;(
        &quot;SELECT * FROM products WHERE id = @Id&quot;,
        new { Id = id });
}

// vs EF Core
public async Task&lt;Product?&gt; GetByIdAsync(int id)
{
    return await _context.Products.FindAsync(id);
}
</code></pre>
<p><strong>When to Use Dapper:</strong></p>
<ul>
<li>Performance-critical queries</li>
<li>Complex SQL that's hard in LINQ</li>
<li>Read-heavy scenarios</li>
<li>Complement to EF Core (use both)</li>
</ul>
<p><strong>Decision:</strong>
Use <strong>EF Core for general data access</strong>, Dapper for <strong>performance-critical</strong> read queries.</p>
<h3 id="adonet-raw-sql">ADO.NET (Raw SQL)</h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Maximum performance</li>
<li>Full control</li>
<li>No dependencies</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Extremely verbose</strong> - 100+ lines for simple CRUD</li>
<li><strong>SQL injection risk</strong> - If not using parameters</li>
<li><strong>Manual mapping</strong> - Code for every property</li>
<li><strong>No migrations</strong> - Manage schema manually</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="lang-csharp">// ADO.NET (verbose!)
public async Task&lt;Product?&gt; GetByIdAsync(int id)
{
    using var connection = new NpgsqlConnection(_connectionString);
    await connection.OpenAsync();

    using var command = connection.CreateCommand();
    command.CommandText = &quot;SELECT id, name, price, category_id FROM products WHERE id = @Id&quot;;
    command.Parameters.AddWithValue(&quot;@Id&quot;, id);

    using var reader = await command.ExecuteReaderAsync();
    if (await reader.ReadAsync())
    {
        return new Product
        {
            Id = reader.GetInt32(0),
            Name = reader.GetString(1),
            Price = reader.GetDecimal(2),
            CategoryId = reader.GetInt32(3)
        };
    }
    return null;
}
</code></pre>
<p><strong>Why Rejected:</strong>
ADO.NET requires 10x more code than EF Core for the same functionality. Use only when maximum performance is critical.</p>
<h3 id="nhibernate">NHibernate</h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Very mature (ported from Java Hibernate)</li>
<li>Powerful</li>
<li>Large feature set</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>XML configuration</strong> - Less C#-friendly than EF Core</li>
<li><strong>Legacy feel</strong> - Not modern .NET</li>
<li><strong>Smaller ecosystem</strong> - Fewer contributors than EF Core</li>
<li><strong>Microsoft doesn't support</strong> - Third-party</li>
</ul>
<p><strong>Why Not Chosen:</strong>
EF Core is Microsoft's official ORM with better .NET integration and larger community.</p>
<hr>
<h2 id="performance-optimization">Performance Optimization</h2>
<p><strong>1. Use AsNoTracking for Read-Only:</strong></p>
<pre><code class="lang-csharp">// ✅ 30% faster for read-only
var products = await _context.Products.AsNoTracking().ToListAsync();
</code></pre>
<p><strong>2. Select Only Needed Columns:</strong></p>
<pre><code class="lang-csharp">// ❌ Loads all columns
var products = await _context.Products.ToListAsync();

// ✅ Only needed columns
var products = await _context.Products
    .Select(p =&gt; new { p.Id, p.Name, p.Price })
    .ToListAsync();
</code></pre>
<p><strong>3. Use Compiled Queries:</strong></p>
<pre><code class="lang-csharp">private static readonly Func&lt;ApplicationDbContext, int, Task&lt;Product?&gt;&gt; GetProductById =
    EF.CompileAsyncQuery((ApplicationDbContext context, int id) =&gt;
        context.Products.FirstOrDefault(p =&gt; p.Id == id));

// Usage (cached execution plan)
var product = await GetProductById(_context, 123);
</code></pre>
<p><strong>4. Batch Operations:</strong></p>
<pre><code class="lang-csharp">// ❌ Slow: One query per item
foreach (var product in products)
{
    _context.Products.Add(product);
    await _context.SaveChangesAsync();  // Don't do this!
}

// ✅ Fast: Single batch
_context.Products.AddRange(products);
await _context.SaveChangesAsync();  // One query
</code></pre>
<hr>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://learn.microsoft.com/en-us/ef/core/">EF Core Documentation</a></li>
<li><a href="https://learn.microsoft.com/en-us/ef/core/performance/">EF Core Performance</a></li>
<li><a href="../../samples/05-RealWorld/MicroserviceTemplate/Infrastructure">Sample Implementation</a></li>
</ul>
<hr>
<h2 id="notes">Notes</h2>
<p><strong>When to Use EF Core:</strong></p>
<ul>
<li>✅ Standard CRUD operations</li>
<li>✅ Complex object graphs</li>
<li>✅ Need migrations</li>
<li>✅ Rapid development</li>
</ul>
<p><strong>When to Use Dapper:</strong></p>
<ul>
<li>✅ Performance-critical queries</li>
<li>✅ Complex reporting</li>
<li>✅ Read-heavy scenarios</li>
</ul>
<p><strong>Common Pitfalls:</strong></p>
<ul>
<li>❌ Not using AsNoTracking for read-only queries</li>
<li>❌ N+1 queries (forgetting Include)</li>
<li>❌ Loading entire tables (use pagination)</li>
<li>❌ Using EF Core for bulk operations (use SqlBulkCopy)</li>
</ul>
<p><strong>Review Date:</strong> 2025-12-01</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dogaaydinn/CSharp-Covariance-Polymorphism-Exercises/blob/master/docs/decisions/0012-use-ef-core-for-data-access.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2024 - Advanced C# Concepts
        </div>
      </div>
    </footer>
  </body>
</html>
