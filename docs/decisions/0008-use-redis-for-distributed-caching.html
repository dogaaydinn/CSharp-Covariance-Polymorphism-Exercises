<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>8. Use Redis for Distributed Caching | Advanced C# Concepts </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="8. Use Redis for Distributed Caching | Advanced C# Concepts ">
      
      
      <link rel="icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../public/docfx.min.css">
      <link rel="stylesheet" href="../../public/main.css">
      <meta name="docfx:navrel" content="">
      <meta name="docfx:tocrel" content="">
      
      <meta name="docfx:rel" content="../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dogaaydinn/CSharp-Covariance-Polymorphism-Exercises/blob/master/docs/decisions/0008-use-redis-for-distributed-caching.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../index.html">
            <img id="logo" class="svg" src="../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="8-use-redis-for-distributed-caching">8. Use Redis for Distributed Caching</h1>

<p><strong>Status:</strong> ✅ Accepted</p>
<p><strong>Date:</strong> 2024-12-01</p>
<p><strong>Deciders:</strong> Architecture Team, Performance Team</p>
<p><strong>Technical Story:</strong> Implementation in <code>samples/06-CuttingEdge/AspireCloudStack</code></p>
<hr>
<h2 id="context-and-problem-statement">Context and Problem Statement</h2>
<p>Modern microservices require caching to:</p>
<ul>
<li>Reduce database load</li>
<li>Improve API response times</li>
<li>Store session data across multiple instances</li>
<li>Implement rate limiting</li>
<li>Cache expensive computations</li>
</ul>
<p><strong>Requirements:</strong></p>
<ul>
<li>Distributed cache (shared across multiple app instances)</li>
<li>Support for TTL (Time To Live)</li>
<li>High performance (sub-millisecond reads)</li>
<li>Pub/Sub support for real-time features</li>
<li>Data structure support (lists, sets, sorted sets, hashes)</li>
</ul>
<p><strong>Traditional in-memory caching problems:</strong></p>
<ul>
<li><code>MemoryCache</code> is per-instance (not shared)</li>
<li>No cache invalidation across instances</li>
<li>Lost when app restarts</li>
<li>Can't use in load-balanced scenarios</li>
</ul>
<hr>
<h2 id="decision-drivers">Decision Drivers</h2>
<ul>
<li><strong>Performance</strong> - Sub-millisecond read/write latency</li>
<li><strong>Distributed</strong> - Shared cache across all instances</li>
<li><strong>Persistence Options</strong> - Can survive restarts if needed</li>
<li><strong>Data Structures</strong> - Beyond key-value (lists, sets, sorted sets)</li>
<li><strong>Pub/Sub</strong> - Real-time messaging capabilities</li>
<li><strong>Cloud Native</strong> - First-class support in all clouds</li>
</ul>
<hr>
<h2 id="considered-options">Considered Options</h2>
<ul>
<li><strong>Option 1</strong> - Redis</li>
<li><strong>Option 2</strong> - In-Memory Cache (MemoryCache)</li>
<li><strong>Option 3</strong> - SQL Server/PostgreSQL as cache</li>
<li><strong>Option 4</strong> - Memcached</li>
</ul>
<hr>
<h2 id="decision-outcome">Decision Outcome</h2>
<p><strong>Chosen option:</strong> &quot;Redis&quot;, because it provides high-performance distributed caching with rich data structures, pub/sub support, persistence options, and excellent .NET integration via StackExchange.Redis.</p>
<h3 id="positive-consequences">Positive Consequences</h3>
<ul>
<li><strong>Blazing Fast</strong> - Sub-millisecond latency (avg 0.1-0.3ms)</li>
<li><strong>Distributed</strong> - All app instances share same cache</li>
<li><strong>Rich Data Types</strong> - Strings, lists, sets, sorted sets, hashes, bitmaps, hyperloglogs</li>
<li><strong>Pub/Sub</strong> - Built-in messaging for real-time features</li>
<li><strong>Persistence</strong> - Optional RDB/AOF for cache survival</li>
<li><strong>TTL Support</strong> - Automatic expiration of keys</li>
<li><strong>Atomic Operations</strong> - INCR, DECR, GETSET, etc.</li>
<li><strong>Cloud Support</strong> - Azure Cache for Redis, AWS ElastiCache, GCP Memorystore</li>
</ul>
<h3 id="negative-consequences">Negative Consequences</h3>
<ul>
<li><strong>External Dependency</strong> - Requires Redis server</li>
<li><strong>Memory Limit</strong> - Data must fit in RAM</li>
<li><strong>Single Point of Failure</strong> - Without clustering/replication</li>
<li><strong>Eviction Policies</strong> - Can lose data when memory full</li>
</ul>
<hr>
<h2 id="pros-and-cons-of-the-options">Pros and Cons of the Options</h2>
<h3 id="redis-chosen">Redis (Chosen)</h3>
<p><strong>What is Redis?</strong></p>
<p>Redis (Remote Dictionary Server) is an in-memory data structure store used as a database, cache, and message broker. Known for exceptional performance and versatile data structures.</p>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>Extremely Fast</strong> - 100K+ ops/sec on single instance</li>
<li><strong>Data Structures</strong> - Lists, sets, sorted sets, hashes, bitmaps, streams</li>
<li><strong>Pub/Sub</strong> - Built-in messaging</li>
<li><strong>Atomic Operations</strong> - Thread-safe increments, decrements</li>
<li><strong>Lua Scripting</strong> - Server-side logic execution</li>
<li><strong>Transactions</strong> - MULTI/EXEC for atomicity</li>
<li><strong>Persistence</strong> - RDB snapshots + AOF logs</li>
<li><strong>Replication</strong> - Master-slave for high availability</li>
<li><strong>Clustering</strong> - Horizontal scaling</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Memory-Only</strong> - Dataset limited by RAM (can use Redis on Flash)</li>
<li><strong>Eviction</strong> - Data lost when memory full (configurable policies)</li>
<li><strong>Single-Threaded</strong> - One command at a time per instance (but pipelined)</li>
<li><strong>Complexity</strong> - Clustering setup requires expertise</li>
</ul>
<p><strong>Docker Compose Setup:</strong></p>
<pre><code class="lang-yaml">version: '3.8'

services:
  redis:
    image: redis:7-alpine
    container_name: myapp-redis
    ports:
      - &quot;6379:6379&quot;
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes  # Enable persistence
    healthcheck:
      test: [&quot;CMD&quot;, &quot;redis-cli&quot;, &quot;ping&quot;]
      interval: 10s
      timeout: 3s
      retries: 5

  redis-commander:  # Web UI for Redis
    image: rediscommander/redis-commander:latest
    container_name: myapp-redis-ui
    environment:
      - REDIS_HOSTS=local:redis:6379
    ports:
      - &quot;8081:8081&quot;
    depends_on:
      - redis

volumes:
  redis-data:
</code></pre>
<p><strong>.NET Aspire (Even Simpler):</strong></p>
<pre><code class="lang-csharp">// AppHost/Program.cs
var builder = DistributedApplication.CreateBuilder(args);

var redis = builder.AddRedis(&quot;redis&quot;)
    .WithRedisCommander()       // Automatically adds Redis Commander UI
    .WithDataVolume();          // Persistent storage

var api = builder.AddProject&lt;Projects.ApiService&gt;(&quot;api&quot;)
    .WithReference(redis);      // Connection string injected automatically!

await builder.Build().RunAsync();

// No docker-compose needed!
// Redis Commander: http://localhost:18888 (Aspire Dashboard shows link)
</code></pre>
<p><strong>.NET Integration:</strong></p>
<pre><code class="lang-csharp">// Install: StackExchange.Redis
// Install: Microsoft.Extensions.Caching.StackExchangeRedis

// Program.cs
builder.Services.AddStackExchangeRedisCache(options =&gt;
{
    options.Configuration = builder.Configuration.GetConnectionString(&quot;Redis&quot;);
    options.InstanceName = &quot;MyApp:&quot;;  // Prefix for all keys
});

// Or use IConnectionMultiplexer for advanced scenarios
builder.Services.AddSingleton&lt;IConnectionMultiplexer&gt;(sp =&gt;
{
    var configuration = ConfigurationOptions.Parse(
        builder.Configuration.GetConnectionString(&quot;Redis&quot;),
        ignoreUnknown: true);

    configuration.AbortOnConnectFail = false;
    configuration.ConnectRetry = 3;
    configuration.ConnectTimeout = 5000;

    return ConnectionMultiplexer.Connect(configuration);
});

// Usage - Simple Caching
public class ProductService
{
    private readonly IDistributedCache _cache;
    private readonly IProductRepository _repository;

    public async Task&lt;Product&gt; GetProductAsync(int id)
    {
        var cacheKey = $&quot;product:{id}&quot;;

        // Try cache first
        var cachedJson = await _cache.GetStringAsync(cacheKey);
        if (cachedJson != null)
        {
            return JsonSerializer.Deserialize&lt;Product&gt;(cachedJson);
        }

        // Cache miss - fetch from database
        var product = await _repository.GetByIdAsync(id);

        // Store in cache (30 minute expiration)
        await _cache.SetStringAsync(
            cacheKey,
            JsonSerializer.Serialize(product),
            new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30)
            });

        return product;
    }
}
</code></pre>
<p><strong>Advanced Redis Features:</strong></p>
<p><strong>1. Atomic Counters (Rate Limiting):</strong></p>
<pre><code class="lang-csharp">public class RateLimiter
{
    private readonly IConnectionMultiplexer _redis;

    public async Task&lt;bool&gt; IsAllowedAsync(string userId, int maxRequests, TimeSpan window)
    {
        var db = _redis.GetDatabase();
        var key = $&quot;rate:{userId}&quot;;

        // Atomic increment
        var current = await db.StringIncrementAsync(key);

        if (current == 1)
        {
            // First request - set expiration
            await db.KeyExpireAsync(key, window);
        }

        return current &lt;= maxRequests;
    }
}

// Usage
if (!await _rateLimiter.IsAllowedAsync(userId, maxRequests: 100, window: TimeSpan.FromMinutes(1)))
{
    return StatusCode(429, &quot;Too many requests&quot;);
}
</code></pre>
<p><strong>2. Distributed Locks:</strong></p>
<pre><code class="lang-csharp">public class DistributedLockService
{
    private readonly IConnectionMultiplexer _redis;

    public async Task&lt;bool&gt; AcquireLockAsync(string resource, string lockId, TimeSpan expiry)
    {
        var db = _redis.GetDatabase();
        var key = $&quot;lock:{resource}&quot;;

        // SET NX EX (Set if Not eXists with EXpiry)
        return await db.StringSetAsync(key, lockId, expiry, When.NotExists);
    }

    public async Task ReleaseLockAsync(string resource, string lockId)
    {
        var db = _redis.GetDatabase();
        var key = $&quot;lock:{resource}&quot;;

        // Lua script ensures we only delete our own lock
        var script = @&quot;
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end&quot;;

        await db.ScriptEvaluateAsync(script, new RedisKey[] { key }, new RedisValue[] { lockId });
    }
}

// Usage - Prevent duplicate processing
var lockId = Guid.NewGuid().ToString();
if (await _lockService.AcquireLockAsync($&quot;process-order:{orderId}&quot;, lockId, TimeSpan.FromSeconds(30)))
{
    try
    {
        await ProcessOrderAsync(orderId);
    }
    finally
    {
        await _lockService.ReleaseLockAsync($&quot;process-order:{orderId}&quot;, lockId);
    }
}
</code></pre>
<p><strong>3. Pub/Sub (Real-Time Messaging):</strong></p>
<pre><code class="lang-csharp">// Publisher
public class NotificationPublisher
{
    private readonly IConnectionMultiplexer _redis;

    public async Task PublishAsync(string channel, string message)
    {
        var subscriber = _redis.GetSubscriber();
        await subscriber.PublishAsync(channel, message);
    }
}

// Subscriber (Background Service)
public class NotificationSubscriber : BackgroundService
{
    private readonly IConnectionMultiplexer _redis;
    private readonly ILogger&lt;NotificationSubscriber&gt; _logger;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        var subscriber = _redis.GetSubscriber();

        await subscriber.SubscribeAsync(&quot;notifications&quot;, (channel, message) =&gt;
        {
            _logger.LogInformation($&quot;Received: {message}&quot;);
            // Handle notification (send email, push notification, etc.)
        });

        await Task.Delay(Timeout.Infinite, stoppingToken);
    }
}

// Usage
await _publisher.PublishAsync(&quot;notifications&quot;, JsonSerializer.Serialize(new
{
    Type = &quot;OrderShipped&quot;,
    OrderId = 12345,
    UserId = &quot;user-123&quot;
}));
</code></pre>
<p><strong>4. Sorted Sets (Leaderboards):</strong></p>
<pre><code class="lang-csharp">public class LeaderboardService
{
    private readonly IConnectionMultiplexer _redis;

    public async Task AddScoreAsync(string userId, double score)
    {
        var db = _redis.GetDatabase();
        await db.SortedSetAddAsync(&quot;leaderboard&quot;, userId, score);
    }

    public async Task&lt;(string UserId, double Score)[]&gt; GetTopAsync(int count)
    {
        var db = _redis.GetDatabase();
        var top = await db.SortedSetRangeByRankWithScoresAsync(
            &quot;leaderboard&quot;,
            start: 0,
            stop: count - 1,
            order: Order.Descending);

        return top.Select(x =&gt; (x.Element.ToString(), x.Score)).ToArray();
    }

    public async Task&lt;long&gt; GetRankAsync(string userId)
    {
        var db = _redis.GetDatabase();
        var rank = await db.SortedSetRankAsync(&quot;leaderboard&quot;, userId, Order.Descending);
        return rank.HasValue ? rank.Value + 1 : -1;  // 1-based ranking
    }
}

// Usage
await _leaderboard.AddScoreAsync(&quot;user123&quot;, 9500);
var top10 = await _leaderboard.GetTopAsync(10);
var userRank = await _leaderboard.GetRankAsync(&quot;user123&quot;);  // e.g., 42
</code></pre>
<p><strong>5. Sets (Session Management):</strong></p>
<pre><code class="lang-csharp">public class SessionService
{
    private readonly IConnectionMultiplexer _redis;

    public async Task AddActiveUserAsync(string userId)
    {
        var db = _redis.GetDatabase();
        await db.SetAddAsync(&quot;active-users&quot;, userId);
    }

    public async Task RemoveActiveUserAsync(string userId)
    {
        var db = _redis.GetDatabase();
        await db.SetRemoveAsync(&quot;active-users&quot;, userId);
    }

    public async Task&lt;long&gt; GetActiveUserCountAsync()
    {
        var db = _redis.GetDatabase();
        return await db.SetLengthAsync(&quot;active-users&quot;);
    }

    public async Task&lt;bool&gt; IsUserActiveAsync(string userId)
    {
        var db = _redis.GetDatabase();
        return await db.SetContainsAsync(&quot;active-users&quot;, userId);
    }
}
</code></pre>
<h3 id="in-memory-cache-memorycache">In-Memory Cache (MemoryCache)</h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Built into .NET (no external dependencies)</li>
<li>Very fast (no network latency)</li>
<li>Simple to use</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Per-Instance</strong> - Each app instance has separate cache</li>
<li><strong>Lost on Restart</strong> - Cache cleared when app restarts</li>
<li><strong>No Distribution</strong> - Can't share across load-balanced instances</li>
<li><strong>Memory Pressure</strong> - Competes with app for RAM</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="lang-csharp">// Works for single instance only!
public class ProductService
{
    private readonly IMemoryCache _cache;

    public async Task&lt;Product&gt; GetProductAsync(int id)
    {
        return await _cache.GetOrCreateAsync($&quot;product:{id}&quot;, async entry =&gt;
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(30);
            return await _repository.GetByIdAsync(id);
        });
    }
}
</code></pre>
<p><strong>When to Use:</strong></p>
<ul>
<li>Single instance applications</li>
<li>Desktop applications</li>
<li>Development/testing only</li>
</ul>
<p><strong>Why Rejected for Microservices:</strong>
Microservices run in multiple instances behind load balancer. MemoryCache would result in cache inconsistency (each instance has different data) and wasted database queries.</p>
<h3 id="sql-serverpostgresql-as-cache">SQL Server/PostgreSQL as Cache</h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Already have the infrastructure</li>
<li>Persistent by default</li>
<li>ACID transactions</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Slow</strong> - 10-100x slower than Redis (disk I/O)</li>
<li><strong>Not Designed for Caching</strong> - No automatic eviction</li>
<li><strong>Schema Required</strong> - Need to define tables</li>
<li><strong>Overhead</strong> - Full RDBMS for simple key-value</li>
</ul>
<p><strong>Why Rejected:</strong>
Using a database for caching defeats the purpose of caching (reducing database load). Redis is 100x faster because it's RAM-only.</p>
<h3 id="memcached">Memcached</h3>
<p><strong>Pros:</strong></p>
<ul>
<li>Simple and fast</li>
<li>Widely adopted</li>
<li>Lower memory overhead than Redis</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Only Key-Value</strong> - No lists, sets, sorted sets</li>
<li><strong>No Persistence</strong> - Always volatile</li>
<li><strong>No Pub/Sub</strong> - Can't use for messaging</li>
<li><strong>Limited Operations</strong> - No atomic increments (in multi-threaded way)</li>
</ul>
<p><strong>Why Not Chosen:</strong>
Memcached is excellent for simple key-value caching, but Redis provides <strong>all of Memcached's benefits plus</strong> rich data structures, pub/sub, Lua scripting, and persistence. The extra features justify the slightly higher memory usage.</p>
<hr>
<h2 id="feature-comparison">Feature Comparison</h2>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Redis</th>
<th>Memcached</th>
<th>MemoryCache</th>
<th>Database</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Performance</strong></td>
<td>✅ &lt; 1ms</td>
<td>✅ &lt; 1ms</td>
<td>✅ &lt; 0.1ms</td>
<td>❌ 10-100ms</td>
</tr>
<tr>
<td><strong>Distributed</strong></td>
<td>✅</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><strong>Persistence</strong></td>
<td>✅ Optional</td>
<td>❌</td>
<td>❌</td>
<td>✅ Always</td>
</tr>
<tr>
<td><strong>Data Structures</strong></td>
<td>✅ Many</td>
<td>❌ Key-Value only</td>
<td>❌ Key-Value</td>
<td>✅ Tables</td>
</tr>
<tr>
<td><strong>TTL</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>⚠️ Manual</td>
</tr>
<tr>
<td><strong>Pub/Sub</strong></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
<td>⚠️ Complex</td>
</tr>
<tr>
<td><strong>Atomic Ops</strong></td>
<td>✅</td>
<td>⚠️ Limited</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td><strong>Clustering</strong></td>
<td>✅</td>
<td>⚠️ Client-side</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="production-deployment">Production Deployment</h2>
<p><strong>Azure Cache for Redis:</strong></p>
<pre><code class="lang-bash">az redis create \
  --name myapp-redis \
  --resource-group myapp-rg \
  --location eastus \
  --sku Standard \
  --vm-size C1 \
  --enable-non-ssl-port false

# Connection string
myapp-redis.redis.cache.windows.net:6380,password=xxx,ssl=True,abortConnect=False
</code></pre>
<p><strong>AWS ElastiCache:</strong></p>
<pre><code class="lang-bash">aws elasticache create-cache-cluster \
  --cache-cluster-id myapp-redis \
  --engine redis \
  --cache-node-type cache.t3.medium \
  --num-cache-nodes 1
</code></pre>
<p><strong>Kubernetes Helm:</strong></p>
<pre><code class="lang-bash">helm install redis bitnami/redis \
  --set auth.password=password \
  --set master.persistence.size=8Gi
</code></pre>
<hr>
<h2 id="best-practices">Best Practices</h2>
<p><strong>1. Key Naming Convention:</strong></p>
<pre><code class="lang-csharp">// Good - Hierarchical, readable
&quot;myapp:user:123:profile&quot;
&quot;myapp:product:456:details&quot;
&quot;myapp:session:abc-def-ghi&quot;

// Bad - Hard to understand
&quot;u123&quot;
&quot;p456&quot;
</code></pre>
<p><strong>2. Set Appropriate TTL:</strong></p>
<pre><code class="lang-csharp">// Frequently changing data - short TTL
await _cache.SetAsync(&quot;trending-products&quot;, data, TimeSpan.FromMinutes(5));

// Rarely changing data - longer TTL
await _cache.SetAsync(&quot;categories&quot;, data, TimeSpan.FromHours(24));

// Static data - very long TTL
await _cache.SetAsync(&quot;country-codes&quot;, data, TimeSpan.FromDays(30));
</code></pre>
<p><strong>3. Cache Invalidation:</strong></p>
<pre><code class="lang-csharp">// When data changes, invalidate cache
public async Task UpdateProductAsync(Product product)
{
    await _repository.UpdateAsync(product);

    // Invalidate cache
    await _cache.RemoveAsync($&quot;product:{product.Id}&quot;);
}
</code></pre>
<p><strong>4. Handle Cache Failures Gracefully:</strong></p>
<pre><code class="lang-csharp">public async Task&lt;Product&gt; GetProductAsync(int id)
{
    try
    {
        var cached = await _cache.GetStringAsync($&quot;product:{id}&quot;);
        if (cached != null)
            return JsonSerializer.Deserialize&lt;Product&gt;(cached);
    }
    catch (RedisException ex)
    {
        _logger.LogWarning(ex, &quot;Redis cache failure, falling back to database&quot;);
        // Continue to database - don't fail the request
    }

    return await _repository.GetByIdAsync(id);
}
</code></pre>
<hr>
<h2 id="links">Links</h2>
<ul>
<li><a href="https://redis.io/documentation">Redis Official Documentation</a></li>
<li><a href="https://stackexchange.github.io/StackExchange.Redis/">StackExchange.Redis</a></li>
<li><a href="https://redis.io/docs/data-types/">Redis Data Types</a></li>
<li><a href="../../samples/06-CuttingEdge/AspireCloudStack">Sample Implementation</a></li>
</ul>
<hr>
<h2 id="notes">Notes</h2>
<p><strong>Common Use Cases:</strong></p>
<ul>
<li>✅ Session storage</li>
<li>✅ API response caching</li>
<li>✅ Rate limiting</li>
<li>✅ Leaderboards</li>
<li>✅ Real-time analytics</li>
<li>✅ Job queues</li>
<li>✅ Pub/Sub messaging</li>
</ul>
<p><strong>When NOT to Use Redis:</strong></p>
<ul>
<li>❌ Primary data storage (use database)</li>
<li>❌ Data larger than RAM</li>
<li>❌ Complex queries and joins (use database)</li>
</ul>
<p><strong>Eviction Policies:</strong></p>
<ul>
<li><code>noeviction</code> - Return errors when memory full (default)</li>
<li><code>allkeys-lru</code> - Evict least recently used keys</li>
<li><code>volatile-lru</code> - Evict LRU keys with TTL</li>
<li><code>allkeys-lfu</code> - Evict least frequently used</li>
</ul>
<p><strong>Review Date:</strong> 2025-12-01</p>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dogaaydinn/CSharp-Covariance-Polymorphism-Exercises/blob/master/docs/decisions/0008-use-redis-for-distributed-caching.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright © 2024 - Advanced C# Concepts
        </div>
      </div>
    </footer>
  </body>
</html>
