<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>ADR-0003: Entity Framework Core for Data Access | Advanced C# Concepts </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="ADR-0003: Entity Framework Core for Data Access | Advanced C# Concepts ">
      
      
      <link rel="icon" href="../../../favicon.ico">
      <link rel="stylesheet" href="../../../public/docfx.min.css">
      <link rel="stylesheet" href="../../../public/main.css">
      <meta name="docfx:navrel" content="">
      <meta name="docfx:tocrel" content="">
      
      <meta name="docfx:rel" content="../../../">
      
      
      <meta name="docfx:docurl" content="https://github.com/dogaaydinn/CSharp-Covariance-Polymorphism-Exercises/blob/master/docs/architecture/01-architecture-decision-records/0003-entity-framework-core-data-access.md/#L1">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../../../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../../../index.html">
            <img id="logo" class="svg" src="../../../logo.svg" alt="">
            
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
              <form class="search" role="search" id="search">
                <i class="bi bi-search"></i>
                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
              </form>
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">

      <div class="content">
        <div class="actionbar">

          <nav id="breadcrumb"></nav>
        </div>

        <article data-uid="">
<h1 id="adr-0003-entity-framework-core-for-data-access">ADR-0003: Entity Framework Core for Data Access</h1>

<p><strong>Status:</strong> Accepted
<strong>Date:</strong> 2025-12-02
<strong>Deciders:</strong> Architecture Team
<strong>Technical Story:</strong> Database abstraction and ORM selection</p>
<h2 id="context">Context</h2>
<p>The VideoService API requires persistent data storage for video metadata with the following needs:</p>
<ul>
<li>CRUD operations for video entities</li>
<li>Strong typing and compile-time safety</li>
<li>Database migrations management</li>
<li>Query optimization capabilities</li>
<li>Cross-database compatibility (PostgreSQL, SQL Server, SQLite)</li>
<li>Integration with dependency injection</li>
<li>Support for async/await patterns</li>
</ul>
<p>We need to choose between:</p>
<ul>
<li>Full ORM (Entity Framework Core, NHibernate)</li>
<li>Micro-ORM (Dapper, RepoDB)</li>
<li>Raw ADO.NET</li>
<li>Custom data access layer</li>
</ul>
<h2 id="decision">Decision</h2>
<p>We will use <strong>Entity Framework Core 8.0</strong> as the data access technology for the AspireVideoService.</p>
<p>Specific configuration:</p>
<ul>
<li>Code-First approach with fluent API configuration</li>
<li>DbContext lifetime: Scoped (per-request)</li>
<li>Migrations: Automatic via <code>EnsureCreatedAsync()</code> for samples</li>
<li>Connection management: Aspire-provided connection strings</li>
<li>Query tracking: As-needed basis</li>
</ul>
<h2 id="consequences">Consequences</h2>
<h3 id="positive">Positive</h3>
<ul>
<li><strong>Productivity</strong>: 80% less code compared to ADO.NET or Dapper</li>
<li><strong>Type Safety</strong>: Compile-time checking of queries via LINQ</li>
<li><strong>Migrations</strong>: Built-in schema versioning and evolution</li>
<li><strong>Change Tracking</strong>: Automatic detection of entity modifications</li>
<li><strong>Relationship Management</strong>: Automatic foreign key handling and navigation properties</li>
<li><strong>Query Optimization</strong>: Query compilation caching and split query support</li>
<li><strong>Aspire Integration</strong>: First-class support via <code>AddNpgsqlDbContext&lt;T&gt;()</code></li>
<li><strong>Testability</strong>: Easy to mock DbContext for unit tests</li>
<li><strong>Community</strong>: Extensive documentation and community support</li>
<li><strong>Cross-Database</strong>: Switch databases with minimal code changes</li>
</ul>
<h3 id="negative">Negative</h3>
<ul>
<li><strong>Performance Overhead</strong>: 10-30% slower than Dapper for simple queries</li>
<li><strong>Memory Usage</strong>: Higher memory footprint due to change tracking</li>
<li><strong>Learning Curve</strong>: Requires understanding of EF Core internals for optimization</li>
<li><strong>Over-fetching Risk</strong>: Easy to accidentally load entire object graphs</li>
<li><strong>N+1 Query Problem</strong>: Can occur if relationships not properly configured</li>
<li><strong>Abstraction Leaks</strong>: Some SQL-specific features require raw SQL</li>
<li><strong>Package Size</strong>: Larger dependency footprint than micro-ORMs</li>
</ul>
<h3 id="neutral">Neutral</h3>
<ul>
<li><strong>Query Translation</strong>: Some LINQ queries may not translate efficiently</li>
<li><strong>Updates Required</strong>: Must keep EF Core packages updated with .NET</li>
<li><strong>Debugging</strong>: SQL queries can be opaque (mitigated with logging)</li>
</ul>
<h2 id="alternatives-considered">Alternatives Considered</h2>
<h3 id="alternative-1-dapper-micro-orm">Alternative 1: Dapper (Micro-ORM)</h3>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>Performance</strong>: 2-3x faster than EF Core for reads</li>
<li><strong>Simplicity</strong>: Thin wrapper over ADO.NET</li>
<li><strong>Control</strong>: Write exact SQL queries</li>
<li><strong>Lightweight</strong>: Minimal dependencies</li>
<li><strong>Mature</strong>: 10+ years of production use</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Manual Mapping</strong>: Must write all SQL and mapping code</li>
<li><strong>No Migrations</strong>: Schema management requires external tools</li>
<li><strong>No Change Tracking</strong>: Must manually track modifications</li>
<li><strong>Boilerplate</strong>: Significantly more code for CRUD operations</li>
<li><strong>Type Safety</strong>: Weaker than EF Core (magic strings for SQL)</li>
</ul>
<p><strong>Why rejected:</strong> Too much boilerplate for an educational sample. EF Core provides better developer experience and demonstrates modern .NET practices.</p>
<h3 id="alternative-2-raw-adonet">Alternative 2: Raw ADO.NET</h3>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>Maximum Performance</strong>: Fastest possible data access</li>
<li><strong>No Dependencies</strong>: Ships with .NET runtime</li>
<li><strong>Full Control</strong>: Complete control over SQL and connections</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Extreme Boilerplate</strong>: 10x more code than EF Core</li>
<li><strong>Error-Prone</strong>: Easy to introduce SQL injection, connection leaks</li>
<li><strong>No Compile-Time Safety</strong>: All SQL is magic strings</li>
<li><strong>Manual Everything</strong>: Mapping, transactions, connection management</li>
<li><strong>Not Educational</strong>: Doesn't demonstrate modern patterns</li>
</ul>
<p><strong>Why rejected:</strong> Unacceptably high maintenance burden. No compelling reason to use raw ADO.NET in modern applications unless performance is critical (&gt;100k requests/second).</p>
<h3 id="alternative-3-nhibernate">Alternative 3: NHibernate</h3>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>Mature</strong>: 15+ years of production use</li>
<li><strong>Feature-Rich</strong>: More features than EF Core (multi-tenancy, etc.)</li>
<li><strong>XML/Code Configuration</strong>: Flexible mapping options</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Legacy Feel</strong>: API design shows its age</li>
<li><strong>XML Configuration</strong>: Most configurations use XML (verbose)</li>
<li><strong>Less .NET-Native</strong>: Ported from Java (Hibernate)</li>
<li><strong>Smaller Community</strong>: Declining community compared to EF Core</li>
<li><strong>No Aspire Integration</strong>: No built-in Aspire support</li>
</ul>
<p><strong>Why rejected:</strong> EF Core is the de facto standard in .NET ecosystem. NHibernate offers no significant advantage for this use case.</p>
<h3 id="alternative-4-mongodb-c-driver-document-db">Alternative 4: MongoDB C# Driver (Document DB)</h3>
<p><strong>Pros:</strong></p>
<ul>
<li><strong>Schemaless</strong>: No migrations required</li>
<li><strong>JSON Native</strong>: Natural fit for APIs</li>
<li><strong>Horizontal Scaling</strong>: Built for distributed systems</li>
</ul>
<p><strong>Cons:</strong></p>
<ul>
<li><strong>Wrong Tool</strong>: Relational data (videos with metadata) fits RDBMS better</li>
<li><strong>No ACID Guarantees</strong>: Eventual consistency may complicate logic</li>
<li><strong>Learning Curve</strong>: Different paradigm than relational</li>
<li><strong>Aspire PostgreSQL</strong>: Sample demonstrates PostgreSQL integration</li>
</ul>
<p><strong>Why rejected:</strong> Video metadata is inherently relational. PostgreSQL with EF Core is the right tool for this data model.</p>
<h2 id="related-decisions">Related Decisions</h2>
<ul>
<li><a href="0004-postgresql-primary-database.html">ADR-0004</a>: PostgreSQL chosen as database</li>
<li><a href="0010-direct-dbcontext-usage.html">ADR-0010</a>: No repository pattern over EF Core</li>
<li><a href="0002-using-dotnet-aspire.html">ADR-0002</a>: Aspire provides EF Core integration</li>
</ul>
<h2 id="related-links">Related Links</h2>
<ul>
<li><a href="https://learn.microsoft.com/ef/core/">EF Core 8 Documentation</a></li>
<li><a href="https://learn.microsoft.com/ef/core/performance/">EF Core Performance</a></li>
<li><a href="https://github.com/DapperLib/Dapper#performance">EF Core vs Dapper Benchmarks</a></li>
<li><a href="https://learn.microsoft.com/dotnet/aspire/database/postgresql-entity-framework-component">Aspire EF Core Integration</a></li>
</ul>
<h2 id="notes">Notes</h2>
<ul>
<li>Use <code>.AsNoTracking()</code> for read-only queries to improve performance</li>
<li>Enable query logging in development: <code>EnableSensitiveDataLogging()</code></li>
<li>Consider <code>AsSplitQuery()</code> for complex queries with includes</li>
<li>Use compiled queries for hot paths (if performance becomes issue)</li>
<li>Future: Evaluate EF Core 9's JSON columns and AOT support</li>
<li>Migrations strategy: Use <code>dotnet ef migrations</code> in production (not <code>EnsureCreated</code>)</li>
</ul>

</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/dogaaydinn/CSharp-Covariance-Polymorphism-Exercises/blob/master/docs/architecture/01-architecture-decision-records/0003-entity-framework-core-data-access.md/#L1" class="edit-link">Edit this page</a>
        </div>

        <div class="next-article d-print-none border-top" id="nextArticle"></div>

      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>

    <div class="container-xxl search-results" id="search-results"></div>

    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright Â© 2024 - Advanced C# Concepts
        </div>
      </div>
    </footer>
  </body>
</html>
