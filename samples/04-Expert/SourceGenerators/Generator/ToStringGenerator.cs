using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace SourceGenerators;

/// <summary>
/// Roslyn Source Generator that auto-generates ToString() methods.
///
/// MODERN APPROACH: Uses IIncrementalGenerator (C# 9+)
/// - Better performance with incremental compilation
/// - Only regenerates when relevant code changes
/// - Reduces IDE lag and build times
/// </summary>
[Generator]
public class ToStringGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // STEP 1: Find all classes with [GenerateToString] attribute
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // STEP 2: Combine with compilation
        IncrementalValueProvider<(Compilation, ImmutableArray<ClassDeclarationSyntax>)> compilationAndClasses
            = context.CompilationProvider.Combine(classDeclarations.Collect());

        // STEP 3: Generate source code
        context.RegisterSourceOutput(compilationAndClasses,
            static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    /// <summary>
    /// PREDICATE: Quick syntax-based filter (runs on every keystroke in IDE)
    /// Only accepts class declarations to reduce work.
    /// </summary>
    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
        => node is ClassDeclarationSyntax classDeclaration
           && classDeclaration.AttributeLists.Count > 0;

    /// <summary>
    /// TRANSFORM: Semantic analysis (runs only on potential targets)
    /// Checks if class has [GenerateToString] attribute.
    /// </summary>
    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        foreach (var attributeList in classDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
                if (symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeClass = attributeSymbol.ContainingType;
                var fullName = attributeClass.ToDisplayString();

                if (fullName == "SourceGenerators.GenerateToStringAttribute")
                    return classDeclaration;
            }
        }

        return null;
    }

    /// <summary>
    /// EXECUTE: Generate ToString() method for each class
    /// </summary>
    private static void Execute(Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax> classes,
        SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        foreach (var classDeclaration in classes.Distinct())
        {
            var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                continue;

            // Generate source code
            var source = GenerateToStringMethod(classSymbol);
            context.AddSource($"{classSymbol.Name}.g.cs", SourceText.From(source, Encoding.UTF8));
        }
    }

    /// <summary>
    /// Generates the actual ToString() method code
    /// </summary>
    private static string GenerateToStringMethod(INamedTypeSymbol classSymbol)
    {
        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : classSymbol.ContainingNamespace.ToDisplayString();

        var className = classSymbol.Name;

        // Get all public properties
        var properties = classSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && !p.IsStatic)
            .ToList();

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("// Generated by ToStringGenerator");
        sb.AppendLine();

        if (namespaceName != null)
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    partial class {className}");
        sb.AppendLine("    {");
        sb.AppendLine("        public override string ToString()");
        sb.AppendLine("        {");

        if (properties.Count == 0)
        {
            sb.AppendLine($"            return \"{className} {{ }}\";");
        }
        else
        {
            // Use {{ and }} for literal braces in the generated interpolated string
            sb.Append("            return $\"" + className + " {{ ");

            for (int i = 0; i < properties.Count; i++)
            {
                var property = properties[i];
                if (i > 0)
                    sb.Append(", ");
                // property.Name appears literally, then {property.Name} is interpolated
                sb.Append(property.Name);
                sb.Append(" = {");
                sb.Append(property.Name);
                sb.Append("}");
            }

            sb.AppendLine(" }}\";");
        }

        sb.AppendLine("        }");
        sb.AppendLine("    }");

        if (namespaceName != null)
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }
}
