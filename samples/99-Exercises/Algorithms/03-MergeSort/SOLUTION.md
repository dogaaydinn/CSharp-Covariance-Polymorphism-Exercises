# ‚ö†Ô∏è SPOILER WARNING ‚ö†Ô∏è

**DO NOT READ UNTIL YOU'VE TRIED YOURSELF!**

---

# MergeSort - Complete Solutions

All solutions are provided in INSTRUCTIONS.md hints section.

## Key Takeaways

1. **Divide and Conquer**: Split ‚Üí Sort ‚Üí Merge
2. **Guaranteed O(n log n)**: No worst case like QuickSort
3. **Stable**: Maintains relative order
4. **Not in-place**: Requires O(n) extra space
5. **Perfect for linked lists**: O(1) merge, no random access

## Complexity Summary

- **Recursive**: O(n log n) time, O(n) space
- **Iterative**: O(n log n) time, O(n) space
- **Inversions**: O(n log n) vs O(n¬≤) brute force
- **Linked List**: O(n log n) time, O(log n) space

## Interview Favorites

‚úÖ **Sort Linked List** (LeetCode #148)
‚úÖ **Count Inversions** (Classic problem)
‚úÖ **Merge K Sorted Lists** (LeetCode #23)

**Why MergeSort beats QuickSort for linked lists:**
- No random access needed (QuickSort needs it)
- O(1) merge by pointer manipulation
- No extra space for merging

**Congratulations! üéâ**

You've completed all 3 Algorithm exercises:
- ‚úÖ Binary Search (O(log n) search)
- ‚úÖ QuickSort (O(n log n) average sort)
- ‚úÖ MergeSort (O(n log n) guaranteed sort)

Next: Generics (Covariance, Contravariance)
